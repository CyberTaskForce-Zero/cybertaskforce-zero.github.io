<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>CyberTaskForce Zero</title>
    <link>/</link>
    <description>Recent content on CyberTaskForce Zero</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>© 2021-2022 CyberTaskForce Zero</copyright>
    <lastBuildDate>Mon, 14 Feb 2022 00:00:00 +0000</lastBuildDate><atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Cyber Security Rumble 2022 - Scramble</title>
      <link>/posts/csr22-scramble/</link>
      <pubDate>Sun, 09 Oct 2022 00:20:13 +0100</pubDate>
      
      <guid>/posts/csr22-scramble/</guid>
      <description>Description: Show me your wordle skills!
Task author: rixxc|RedRocket
nc scamble.rumble.host 2568 The service running looks like this:
#!/usr/bin/env python3 import random import string from secret import FLAG NUMBER_OF_GAMES = 100 THRESHOLD = 5 SIZE_OF_WORDLIST = 12000 rng = random.SystemRandom() def game(secret_word, wordlist): print(&amp;quot;[start game]&amp;quot;) chars = set(secret_word) for guess_count in range(1, 7): guess = input(&amp;quot;&amp;gt; &amp;quot;)[:5] assert(len(guess) == 5) assert(guess in wordlist) if guess == secret_word: print(&amp;quot;[guess correct]&amp;gt; &amp;quot;) break result = &amp;quot;&amp;quot; for i in range(5): if guess[i] == secret_word[i]: result += &amp;quot;+&amp;quot; elif guess[i] in chars: result += &amp;quot;*&amp;quot; else: result += &amp;quot;-&amp;quot; print(result) else: print(&amp;quot;[number of guesses exceeded]&amp;gt; &amp;quot;) return guess_count def main(): wordlist = set() while len(wordlist) &amp;lt; SIZE_OF_WORDLIST: word = &#39;&#39;.</description>
      <content>&lt;h4 id=&#34;description&#34;&gt;Description:&lt;/h4&gt;
&lt;p&gt;Show me your wordle skills!&lt;/p&gt;
&lt;p&gt;Task author: rixxc|RedRocket&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nc scamble.rumble.host 2568
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The service running looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python=&#34; data-lang=&#34;python=&#34;&gt;#!/usr/bin/env python3

import random
import string
from secret import FLAG

NUMBER_OF_GAMES = 100
THRESHOLD = 5
SIZE_OF_WORDLIST = 12000

rng = random.SystemRandom()


def game(secret_word, wordlist):
    print(&amp;quot;[start game]&amp;quot;)
    chars = set(secret_word)

    for guess_count in range(1, 7):
        guess = input(&amp;quot;&amp;gt; &amp;quot;)[:5]
        assert(len(guess) == 5)
        assert(guess in wordlist)

        if guess == secret_word:
            print(&amp;quot;[guess correct]&amp;gt; &amp;quot;)
            break

        result = &amp;quot;&amp;quot;
        for i in range(5):
            if guess[i] == secret_word[i]:
                result += &amp;quot;+&amp;quot;
            elif guess[i] in chars:
                result += &amp;quot;*&amp;quot;
            else:
                result += &amp;quot;-&amp;quot;

        print(result)
    else:
        print(&amp;quot;[number of guesses exceeded]&amp;gt; &amp;quot;)

    return guess_count


def main():
    wordlist = set()
    while len(wordlist) &amp;lt; SIZE_OF_WORDLIST:
        word = &#39;&#39;.join(rng.choices(string.ascii_uppercase, weights=[7.58, 1.96, 3.16, 4.98, 18.93, 1.49, 3.02, 4.98, 8.02, 0.24, 1.32, 3.60, 2.55, 12.53, 2.24, 0.67, 0.02, 6.89, 8.42, 7.79, 3.83, 0.84, 1.78, 0.05, 0.05, 1.21], k=5))
        wordlist.add(word)

    print(&amp;quot;Here is your personal wordlist:&amp;quot;)
    print(&amp;quot;[begin of wordlist]&amp;quot;)
    for word in wordlist:
        print(word)
    print(&amp;quot;[end of wordlist]&amp;quot;)

    guesses = []
    for _ in range(NUMBER_OF_GAMES):
        secret_word = rng.choice(list(wordlist))
        guesses.append(game(secret_word, wordlist))

    average_guesses = sum(guesses) / NUMBER_OF_GAMES
    print(f&#39;avg.: {average_guesses}&#39;)
    if average_guesses &amp;lt; THRESHOLD:
        print(FLAG)


if __name__ == &#39;__main__&#39;:
    main()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Summarized we need to solve a game of wordle 100 times with an average guess num of less than 5.
This is humanely possible, but not in the given timeframe, therefore we need to automize it.&lt;/p&gt;
&lt;p&gt;We found an article about &lt;a href=&#34;https://aditya-sengupta.github.io/coding/2022/01/13/wordle.html&#34;&gt;entropy-based wordle solving&lt;/a&gt; from Aditya Sengupta and an implementation in the Julia programming language.&lt;/p&gt;
&lt;p&gt;Then we rewrote his &lt;a href=&#34;https://github.com/aditya-sengupta/wordle-solver/blob/main/src/WordleSolver.jl&#34;&gt;wordle-solver&lt;/a&gt; in python:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;// wordle_doer.py&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python=&#34; data-lang=&#34;python=&#34;&gt;from collections import Counter
from scipy.stats import entropy
import string

class WordleDoer:
    def __init__(self, wordlist, wordlength) -&amp;gt; None:
        self.wordlist = wordlist
        self.wordlength = wordlength
        self.corpus = []
        self.first_guess = None

    def reset(self):
        self.corpus = self.wordlist

    def guessToList(self, guess):
        result = [None] * self.wordlength
        conversionMap = {
            &#39;+&#39;: 2,
            &#39;*&#39;: 1,
            &#39;-&#39;: 0
        }
        for i in range(0, 5):
            result[i] = conversionMap[guess[i]]

        return result


    def listToGuess(self, list: list):
        guess = [&#39;-&#39;] * 5
        conversionMap = {
            2: &#39;+&#39;,
            1: &#39;*&#39;,
            0: &#39;-&#39;
        }
        for i in range(0, 5):
            guess[i] = conversionMap[list[i]]

        return &#39;&#39;.join(guess)


    def constrain(self, query, result):
        self.corpus = [word for word in self.corpus if self.guess(query, word) == result]


    def guess(self, query, word):
        result = [0] * self.wordlength

        for i in range(0, self.wordlength):
            if word[i] == query[i]:
                result[i] = 2

        for i in range(0, self.wordlength):
            if query[i] in word and result[i] != 2:
                result[i] = 1

        return self.listToGuess(result)

    def choose(self):
        print(len(self.corpus))
        if len(self.corpus) == 0:
            return None
        if len(self.corpus) == 1:
            return self.corpus[0]
        if self.first_guess is not None and len(self.corpus) == len(self.wordlist):
            return self.first_guess

        is_known = [all(x[i] == self.corpus[0][i] for x in self.corpus) for i in range(0, self.wordlength)]
        word_so_far = &amp;quot;&amp;quot;.join([self.corpus[0][j] if is_known[j] else &#39;0&#39; for j in range(0, self.wordlength)])
        char_occurences = {}
        for char in string.ascii_uppercase:
            char_occurences[char] = [sum([word[j].count(char) for word in self.corpus]) for j in range(0, self.wordlength)]
        best_word = self.corpus[0]
        best_diff_entropy = 0
        for word in self.corpus:
            diff_entropy = 0
            seen_chars = set()
            for (i, char) in enumerate(word):
                greens = char_occurences[char][i]
                if not (char in seen_chars):
                    mask = [ch != char for ch in word_so_far]
                    yellows = sum([char_occurences[char][i] for i in range(0, self.wordlength) if mask[i]]) - greens
                    seen_chars.add(char)
                else:
                    yellows = 0
                greys = len(self.corpus) - yellows - greens
                dist = [greens, yellows, greys]
                sumdist = sum(dist)
                dist = [entry / sumdist for entry in dist]
                diff_entropy = diff_entropy + entropy(dist)
            if diff_entropy &amp;gt;= best_diff_entropy:
                best_diff_entropy = diff_entropy
                best_word = word

        if self.first_guess is None:
            self.first_guess = best_word

        return best_word
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Our implementation has the following changes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;We are caching the first guess, because
&lt;ul&gt;
&lt;li&gt;the wordlist doesn&amp;rsquo;t change between games&lt;/li&gt;
&lt;li&gt;the first guess takes up the most time&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;We dumbed down the &lt;code&gt;guess&lt;/code&gt; method to match the given game
&lt;ul&gt;
&lt;li&gt;The game implementation does not Count occurences&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Because we need to win 100 games with high reliability, we needed to automize it:
&lt;code&gt;doit.py&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python=&#34; data-lang=&#34;python=&#34;&gt;#!/usr/bin/python

from pwn import *
from wordle_doer import WordleDoer
import re

r = remote(&amp;quot;scamble.rumble.host&amp;quot;, 2568)
#r = remote(&amp;quot;localhost&amp;quot;, 2568)

rateMatcher = re.compile(&amp;quot;\s?[\*+-]{5}\s?&amp;quot;)

r.recvuntil(b&amp;quot;[begin of wordlist]\n&amp;quot;)
wordlist = [word.decode() for word in r.recvuntil(b&amp;quot;[end of wordlist]\n&amp;quot;, True).splitlines(False)]

solver = WordleDoer(wordlist, 5)

while True:
    start = r.recvuntil([b&amp;quot;avg.:&amp;quot;, b&amp;quot;[start game]&amp;quot;])
    if start.startswith(b&amp;quot;avg.:&amp;quot;):
        print(start)
        print(r.recvline())
        break
    print(&amp;quot;Game started&amp;quot;)
    solver.reset()
    while True:
        guess = solver.choose()
        if len(guess) != 5:
            print(solver.corpus)
        print(&amp;quot;My guess: &#39;&amp;quot; + guess + &#39;&amp;quot;&#39;)
        command = r.recvuntil(b&amp;quot;&amp;gt; &amp;quot;, True)
        print(b&amp;quot;command: &amp;quot; + command)
        if b&amp;quot;[guess correct]&amp;quot; in command or b&amp;quot;[number of guesses exceeded]&amp;quot; in command:
            break
        r.sendline(guess.encode())
        response = r.recvline().decode().replace(&amp;quot;\n&amp;quot;, &amp;quot;&amp;quot;)
        if not rateMatcher.match(response):
            print(&amp;quot;Start anew: &amp;quot; + response)
            break
        print(&amp;quot;Response: &#39;&amp;quot; + response + &amp;quot;&#39;&amp;quot;)
        solver.constrain(guess, response)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;That&amp;rsquo;s it!&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title>Cyber Security Rumble 2022 - Misc Me Plx</title>
      <link>/posts/csr22-misc-me-plx/</link>
      <pubDate>Sat, 08 Oct 2022 23:59:13 +0100</pubDate>
      
      <guid>/posts/csr22-misc-me-plx/</guid>
      <description>Description: I like to sniff buses.
Challenge author: Skipper|RedRocket
We get:
90K recording.sr one unzip later
 10M logic-1-1 10M logic-1-2 10M logic-1-3 10M logic-1-4 10M logic-1-5 10M logic-1-6 10M logic-1-7 10M logic-1-8 7,5M logic-1-9 201 metadata 90K recording.sr 1 version # cat metadata [global] sigrok version=0.5.2 [device 1] capturefile=logic-1 total probes=8 samplerate=24 MHz total analog=0 probe1=D0 probe2=D1 probe3=D2 probe4=D3 probe5=D4 probe6=D5 probe7=D6 probe8=D7 unitsize=1 View it in PulseView (GUI of sigrok)</description>
      <content>&lt;h4 id=&#34;description&#34;&gt;Description:&lt;/h4&gt;
&lt;p&gt;I like to sniff buses.&lt;/p&gt;
&lt;p&gt;Challenge author: Skipper|RedRocket&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/img/csr22_bus_sniffer.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;We get:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;90K recording.sr
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;em&gt;one &lt;code&gt;unzip&lt;/code&gt; later&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; 10M logic-1-1
 10M logic-1-2
 10M logic-1-3
 10M logic-1-4
 10M logic-1-5
 10M logic-1-6
 10M logic-1-7
 10M logic-1-8
7,5M logic-1-9
 201 metadata
 90K recording.sr
   1 version
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;# cat metadata

[global]
sigrok version=0.5.2

[device 1]
capturefile=logic-1
total probes=8
samplerate=24 MHz
total analog=0
probe1=D0
probe2=D1
probe3=D2
probe4=D3
probe5=D4
probe6=D5
probe7=D6
probe8=D7
unitsize=1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;View it in PulseView (GUI of sigrok)&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/img/csr22_pulse.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;D7 looks like a clock pulse.
When googling &amp;ldquo;clock bus protocol&amp;rdquo; &lt;strong&gt;I²C&lt;/strong&gt; seems to pop up quite often.
I try adding a decoder using the sigrok-cli:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# sigrok -i ~/ctf/csr22/miscmeplx/recording.sr -P i2c:scl=D7:sda=D6 | grep &amp;quot;Data write&amp;quot;
i2c-1: Data write: 69
i2c-1: Data write: 6E
i2c-1: Data write: 69
i2c-1: Data write: 74
i2c-1: Data write: 5F
i2c-1: Data write: 70
i2c-1: Data write: 72
i2c-1: Data write: 6F
i2c-1: Data write: 67
i2c-1: Data write: 5F
...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;After converting the bytes to ascii we see:
&lt;code&gt;init_prog_addr__77_1_2_01șCSR{i2c_d0_b3_v3ry_31337}_|&amp;gt;|&amp;gt;|&amp;gt;򀀀&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Yeah!&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/img/csr22_doggo.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title>UIUCTF 2022: mom can we have AES</title>
      <link>/posts/uiuctf2022-mom-can-we-have-aes/</link>
      <pubDate>Mon, 01 Aug 2022 13:27:00 +0200</pubDate>
      
      <guid>/posts/uiuctf2022-mom-can-we-have-aes/</guid>
      <description>The challenge consists of two services communicating with each other: server.py on port 1337 and client.py on port 1338.
Services Most part of the provided services is used for initializing AES, which is done with a protocol very similar to TLS. In the following I will explain the initialization in the order of the communication and will therefore switch between client.py and server.py.
.--------. .--------. | client | | server | &#39;--------&#39; &#39;--------&#39; | AES modes | | -----------------------------------&amp;gt; | | client random | | -----------------------------------&amp;gt; | | | | signed hash of certificate | | &amp;lt;----------------------------------- | | AES modes | | &amp;lt;----------------------------------- | | server random | | &amp;lt;----------------------------------- | | | | RSA encrypted premaster secret | | -----------------------------------&amp;gt; | | AES mode | | -----------------------------------&amp;gt; | | AES encrypted finish | | -----------------------------------&amp;gt; | | | Both scripts start with the same imports and by defining the supported AES modes:</description>
      <content>&lt;p&gt;The challenge consists of two services communicating with each other: &lt;a href=&#34;https://2022.uiuc.tf/files/db45f0c6d5e88ae21c97ba4641f6971d/server.py&#34;&gt;&lt;code&gt;server.py&lt;/code&gt;&lt;/a&gt; on port 1337 and &lt;a href=&#34;https://2022.uiuc.tf/files/ebccf298bcd26b5b2258ec4279202f2f/client.py&#34;&gt;&lt;code&gt;client.py&lt;/code&gt;&lt;/a&gt; on port 1338.&lt;/p&gt;
&lt;h1 id=&#34;services&#34;&gt;Services&lt;/h1&gt;
&lt;p&gt;Most part of the provided services is used for initializing AES, which is done with a protocol very similar to TLS. In the following I will explain the initialization in the order of the communication and will therefore switch between &lt;code&gt;client.py&lt;/code&gt; and &lt;code&gt;server.py&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-goat&#34; data-lang=&#34;goat&#34;&gt;.--------.                            .--------.
| client |                            | server |
&#39;--------&#39;                            &#39;--------&#39;
    |              AES modes               |
    | -----------------------------------&amp;gt; |
    |            client random             |
    | -----------------------------------&amp;gt; |
    |                                      |
    |       signed hash of certificate     |
    | &amp;lt;----------------------------------- |
    |              AES modes               |
    | &amp;lt;----------------------------------- |
    |            server random             |
    | &amp;lt;----------------------------------- |
    |                                      |
    |    RSA encrypted premaster secret    |
    | -----------------------------------&amp;gt; |
    |               AES mode               |
    | -----------------------------------&amp;gt; |
    |         AES encrypted finish         |
    | -----------------------------------&amp;gt; |
    |                                      |

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Both scripts start with the same imports and by defining the supported AES modes:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;from&lt;/span&gt; Crypto.Util.Padding &lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; pad, unpad
&lt;span style=&#34;color:#f92672&#34;&gt;from&lt;/span&gt; Crypto.PublicKey &lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; RSA
&lt;span style=&#34;color:#f92672&#34;&gt;from&lt;/span&gt; Crypto.Cipher &lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; AES, PKCS1_OAEP
&lt;span style=&#34;color:#f92672&#34;&gt;from&lt;/span&gt; Crypto.Hash &lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; SHA256
&lt;span style=&#34;color:#f92672&#34;&gt;from&lt;/span&gt; Crypto.Signature &lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; PKCS1_v1_5

&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; random
&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; string

&lt;span style=&#34;color:#f92672&#34;&gt;from&lt;/span&gt; fields &lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; cert, block_size
&lt;span style=&#34;color:#f92672&#34;&gt;from&lt;/span&gt; secret &lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; flag

cipher_suite &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;AES.MODE_CBC&amp;#34;&lt;/span&gt; : AES&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;MODE_CBC, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;AES.MODE_CTR&amp;#34;&lt;/span&gt; : AES&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;MODE_CTR, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;AES.MODE_EAX&amp;#34;&lt;/span&gt; : AES&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;MODE_EAX, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;AES.MODE_GCM&amp;#34;&lt;/span&gt; : AES&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;MODE_GCM,  &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;AES.MODE_ECB&amp;#34;&lt;/span&gt; : AES&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;MODE_ECB}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The initialization begins at the client by generating four random characters and sending them together with the supported AES modes to the server. TLS uses much larger random values (32 byte) and will send some additional information such as the protocol version.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;########## Client Hello ##########&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;# Cipher suite&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;cipher_suite&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;keys(), sep&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;, &amp;#39;&lt;/span&gt;)

client_random &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;join(random&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;SystemRandom()&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;choice(string&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;ascii_uppercase &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; string&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;digits) &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; _ &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;))
&lt;span style=&#34;color:#75715e&#34;&gt;# Client random&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt;(client_random)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The server receives both and stores them for later use.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;########## Client Hello ##########&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;# Enter encryption methods&lt;/span&gt;
input_encryptions_suite &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; input()
client_cipher_suite &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; input_encryptions_suite&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;split(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;, &amp;#34;&lt;/span&gt;)
&lt;span style=&#34;color:#75715e&#34;&gt;# Enter client random&lt;/span&gt;
client_random &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; input()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Now the server proceeds with sending his own hello, starting with a signed hash of his certificate. In TLS, the server would send the actual certificate and a signed hash of all previous messages.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;########## Server Hello ##########&lt;/span&gt;

&lt;span style=&#34;color:#75715e&#34;&gt;# Certificate&lt;/span&gt;
private_key &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; RSA&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;import_key(open(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;my_credit_card_number.pem&amp;#34;&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;read())
cipher_hash &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; SHA256&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;new(cert)
signature &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; PKCS1_v1_5&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;new(private_key)&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;sign(cipher_hash)
&lt;span style=&#34;color:#75715e&#34;&gt;#Signed certificate&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt;(signature&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;hex())
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;After that the server computes the intersection of the AES modes supported by him and the client and sends the resulting list back to the client. In TLS, the server chooses one of the ciphers that is understood by client and server and sends only the selected cipher to the client.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# select cipher suite&lt;/span&gt;
selected_cipher_suite &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {}
&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; method &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; cipher_suite:
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; method &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; client_cipher_suite:
        selected_cipher_suite[method] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; cipher_suite[method]

&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; len(selected_cipher_suite) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;:
    &lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Honey, we have a problem. I&amp;#39;m sorry but I&amp;#39;m disowning you :(&amp;#34;&lt;/span&gt;)
    exit()

&lt;span style=&#34;color:#75715e&#34;&gt;# Selected cipher suite&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;selected_cipher_suite&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;keys(), sep&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;, &amp;#39;&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Finally, the server generates four random characters and sends them to the client. As with the client random, TLS will generate a 32 byte long random value.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;server_random &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;join(random&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;SystemRandom()&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;choice(string&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;ascii_uppercase &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; string&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;digits) &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; _ &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;))
&lt;span style=&#34;color:#75715e&#34;&gt;# Server random&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt;(server_random)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Now back to the client. It first loads the preshared public key of the server and verifies the signature. As the certificate is preshared in this case, the server didn&amp;rsquo;t have to send it. Furthermore in TLS the public key would be read from the certificate and not from a separate file. As an alternative to certificates, TLS supports the Diffie-Hellman key exchange, which is covered in last years UIUCTF challenge &lt;a href=&#34;/posts/uiuctf2021-dhke-intro/&#34;&gt;&lt;code&gt;dhke_intro&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;########## Server Hello ##########&lt;/span&gt;

&lt;span style=&#34;color:#75715e&#34;&gt;# verify server&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;# Enter signed certificate&lt;/span&gt;
server_signature_hex &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; input()
server_signature &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; bytearray&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;fromhex(server_signature_hex)
public_key &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; RSA&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;import_key(open(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;receiver.pem&amp;#34;&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;read())
cipher_hash &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; SHA256&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;new(cert)
verifier &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; PKCS1_v1_5&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;new(public_key)

&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;not&lt;/span&gt; verifier&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;verify(cipher_hash, server_signature):
    &lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Mom told me not to talk to strangers.&amp;#34;&lt;/span&gt;)
    exit()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;As next step, the client parses the cipher suits supported by the server.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# Enter selected cipher suite&lt;/span&gt;
input_encryptions_suite &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; input()
&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; len(input_encryptions_suite) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;:
    &lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34; nO SeCUriTY :/&amp;#34;&lt;/span&gt;)
    exit()

selected_cipher_suite &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {}
input_encryptions_suite &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; input_encryptions_suite&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;split(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;, &amp;#34;&lt;/span&gt;)
&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; method &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; input_encryptions_suite:
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; method &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; cipher_suite:
        selected_cipher_suite[method] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; cipher_suite[method]

&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; len(selected_cipher_suite) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;:
    &lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;I&amp;#39;m a rebellious kid who refuses to talk to people who don&amp;#39;t speak my language.&amp;#34;&lt;/span&gt;)
    exit()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;As last part of the parsing of the server hello, the random characters from the server are stored for later use.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# Enter server random&lt;/span&gt;
server_random &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; input()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;As next step, the client initializes AES, starting with the generation of the premaster secret. This is then encrypted and send to the server. As in previous cases, the premaster secret of TLS is larger and uses 48 bytes.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;premaster_secret &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;join(random&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;SystemRandom()&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;choice(string&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;ascii_uppercase &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; string&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;digits) &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; _ &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(&lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;))

cipher_rsa &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; PKCS1_OAEP&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;new(public_key)
premaster_secret_encrypted &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; cipher_rsa&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;encrypt(premaster_secret&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;encode())&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;hex()
&lt;span style=&#34;color:#75715e&#34;&gt;# Encrypted premaster secret&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt;(premaster_secret_encrypted)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Then the session key is computed from the previously generated premaster secret and both random values.
Because the premaster secret is send encrypted, the session key is only known to the client and server. The use of client and server random prevents replay attacks, as the target of the replay will choose a different one. This is especially true for TLS, since 4 of the 32 bytes of the client and server random are the current timestamp.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;session_key &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; SHA256&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;new((client_random &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; server_random &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; premaster_secret)&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;encode())&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;hexdigest()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Now the client chooses one of the ciphers supported by client and server and informs the server about the selected cipher.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;chosen_cipher_name &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; next(iter(selected_cipher_suite))
&lt;span style=&#34;color:#75715e&#34;&gt;# Using encryption mode&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt;(chosen_cipher_name)
cipher &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; AES&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;new(session_key&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;encode()[:&lt;span style=&#34;color:#ae81ff&#34;&gt;16&lt;/span&gt;], cipher_suite[chosen_cipher_name])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The server receives the premaster secret, decrypts it with its private key and uses it to calculate the same session key.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;########## ClientKeyExchange &amp;amp; CipherSpec Finished ##########&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;# Enter premaster secret&lt;/span&gt;
encrypted_premaster_secret &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; input()
cipher_rsa &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; PKCS1_OAEP&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;new(private_key)
premaster_secret &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; cipher_rsa&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;decrypt(bytearray&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;fromhex(encrypted_premaster_secret))&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;decode(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;utf-8&amp;#39;&lt;/span&gt;)

session_key &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; SHA256&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;new((client_random &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; server_random &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; premaster_secret)&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;encode())&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;hexdigest()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;After that, the server will check wether the selected cipher is one of the supported ones and will then initialize AES with the session key and the selected mode.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# Enter chosen cipher&lt;/span&gt;
chosen_cipher_name &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; input()
&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; chosen_cipher_name &lt;span style=&#34;color:#f92672&#34;&gt;not&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; selected_cipher_suite:
    &lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;No honey, I told you we&amp;#39;re not getting &amp;#34;&lt;/span&gt;, chosen_cipher_name, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;.&amp;#39;&lt;/span&gt;, sep&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;#39;&lt;/span&gt;)
    exit()
cipher &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; AES&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;new(session_key&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;encode()[:&lt;span style=&#34;color:#ae81ff&#34;&gt;16&lt;/span&gt;], cipher_suite[chosen_cipher_name])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Finally the client sends an AES encrypted &lt;code&gt;finish&lt;/code&gt; to the server.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# Encrypted finish message&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt;(cipher&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;encrypt(pad(&lt;span style=&#34;color:#e6db74&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;finish&amp;#34;&lt;/span&gt;, block_size))&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;hex())
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The server decrypts the &lt;code&gt;finish&lt;/code&gt; and checks wether it is correct. This is a final proof, that both sides have calculated the same session key.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# Enter encrypted finish&lt;/span&gt;
client_finish &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; input()
client_finish &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; bytearray&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;fromhex(client_finish)

&lt;span style=&#34;color:#75715e&#34;&gt;########## ServerKeyExchange &amp;amp; CipherSpec Finished ##########&lt;/span&gt;

finish_msg &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; unpad(cipher&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;decrypt(client_finish), block_size)
&lt;span style=&#34;color:#66d9ef&#34;&gt;assert&lt;/span&gt;(finish_msg &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;finish&amp;#39;&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In TLS, the server would also send a finish message over the encrypted channel to proof the client the it has the same session key. In this challenge, the message is not send but the client wants to receive an unencrypted &lt;code&gt;finish&lt;/code&gt; and checks it.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;########## ServerKeyExchange &amp;amp; CipherSpec Finished ##########&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;# Confirm finish&lt;/span&gt;
finish_msg &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; input()
&lt;span style=&#34;color:#66d9ef&#34;&gt;assert&lt;/span&gt;(finish_msg &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;finish&amp;#34;&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Now the connection is established and the contents can be exchanged.&lt;/p&gt;
&lt;p&gt;The server checks each message if it exactly matches the flag and prints a message indicating the result.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;########## Communication ##########&lt;/span&gt;

&lt;span style=&#34;color:#75715e&#34;&gt;# Listening...&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; True:
    client_msg &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; input()
    client_msg &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; unpad(cipher&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;decrypt(bytearray&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;fromhex(client_msg)), block_size)

    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; client_msg &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; flag:
        &lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;That is correct.&amp;#34;&lt;/span&gt;)
    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;:
        &lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;You are not my son.&amp;#34;&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This has little to no interest for us, since we would have to guess the whole flag at once, which is way to much effort. We can only use it to verify the flag.&lt;/p&gt;
&lt;p&gt;The client is much more useful. It requests a hex-encoded prefix, appends the flag to the decoded prefix and prints the AES encrypted result.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;########## Communication ##########&lt;/span&gt;

&lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; True:
    prefix &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; input()
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; len(prefix) &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;:
        prefix &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; bytearray&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;fromhex(prefix)
        extended_flag &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; prefix &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; flag
    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;:
        extended_flag &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; flag
    
    ciphertext &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; cipher&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;encrypt(pad(extended_flag, block_size))&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;hex()
    &lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt;(str(ciphertext))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This enables us to brute force the flag character by character, which can be done in a few minutes.&lt;/p&gt;
&lt;h1 id=&#34;exploit&#34;&gt;Exploit&lt;/h1&gt;
&lt;p&gt;For solving the challenge, we used pwntools&amp;rsquo; &lt;a href=&#34;https://docs.pwntools.com/en/stable/tubes/sockets.html#pwnlib.tubes.remote.remote&#34;&gt;&lt;code&gt;remote&lt;/code&gt;&lt;/a&gt; for the communication with the services and python&amp;rsquo;s &lt;code&gt;string&lt;/code&gt; to obtain a list of flag characters.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;from&lt;/span&gt; pwn &lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; string
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;First we have to initialize the connection to the client. Therefore we connect to the client and server and relay the messages from the server to the client and vice versa.&lt;/p&gt;
&lt;p&gt;After connecting to the services,&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;get_services&lt;/span&gt;():
    &lt;span style=&#34;color:#75715e&#34;&gt;# connect to server and client&lt;/span&gt;
    server &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; remote(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;mom-can-we-have-aes.chal.uiuc.tf&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1337&lt;/span&gt;)
    client &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; remote(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;mom-can-we-have-aes.chal.uiuc.tf&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1338&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;the services will send &lt;code&gt;== proof-of-work: disabled ==\n&lt;/code&gt;, which we have to skip, since this is not part of the protocol.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# skip proof of work message&lt;/span&gt;
    client&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;recvline()
    server&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;recvline()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;As first message, the client will send us the supported AES modes. As we want to use ECB, we drop the received list and send only &lt;code&gt;AES.MODE_ECB&lt;/code&gt; to the server. We will explain this decision later, when we actually use the properties of this mode.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# AES modes&lt;/span&gt;
    client&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;recvline()
    server&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;sendline(&lt;span style=&#34;color:#e6db74&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;AES.MODE_ECB&amp;#34;&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The remaining initialization can be relayed.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# client random&lt;/span&gt;
    server&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;send(client&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;recvline())

    &lt;span style=&#34;color:#75715e&#34;&gt;# server signature&lt;/span&gt;
    client&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;send(server&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;recvline())

    &lt;span style=&#34;color:#75715e&#34;&gt;# server AES mode&lt;/span&gt;
    client&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;send(server&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;recvline())

    &lt;span style=&#34;color:#75715e&#34;&gt;# server random&lt;/span&gt;
    client&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;send(server&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;recvline())

    &lt;span style=&#34;color:#75715e&#34;&gt;# client encrypted premaster secret&lt;/span&gt;
    server&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;send(client&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;recvline())

    &lt;span style=&#34;color:#75715e&#34;&gt;# client chosen AES mode&lt;/span&gt;
    server&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;send(client&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;recvline())

    &lt;span style=&#34;color:#75715e&#34;&gt;# client finish&lt;/span&gt;
    finish &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; client&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;recvline()
    server&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;send(finish)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Since the client expects a plain text &lt;code&gt;finish&lt;/code&gt; and the server does not send it, we must send it ourselves. After that we have a server and a client in their main loop, which can be returned.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# send finish for client&lt;/span&gt;
    client&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;sendline(&lt;span style=&#34;color:#e6db74&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;finish&amp;#34;&lt;/span&gt;)

    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; server, client
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Now we come to the actual exploit and the chosen AES mode.&lt;/p&gt;
&lt;p&gt;AES works by dividing the message to encrypt in blocks of 16 bytes. The difference between the modes is the handling of these blocks. The simplest mode is &lt;em&gt;Electronic CodeBook&lt;/em&gt; (ECB), which just takes each block and encrypts it separately. This has the effect, that the same plain text block will always result in the same encrypted block. Because of this, structures are retained. A popular example for this property is the &lt;a href=&#34;https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#ECB&#34;&gt;ECB encrypted Tux&lt;/a&gt;. As a result of this insecureness, ECB is not part of the ciphers available in TLS.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-goat&#34; data-lang=&#34;goat&#34;&gt; .-------------.          .-------------.
 | plaintext 1 |          | plaintext 2 |
 &#39;-------------&#39;          &#39;-------------&#39;
        |                        |
        v                        v
   .---------.              .---------.
   | encrypt |              | encrypt |
   &#39;---------&#39;              &#39;---------&#39;
        |                        |
        v                        v
.--------------.         .--------------.
| ciphertext 1 |         | ciphertext 2 |
&#39;--------------&#39;         &#39;--------------&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We can use this insecureness to our advantage. If we send a prefix, the flag is moved to the right, resulting in a different alignment against the block boundaries. By changing the length of the prefix, we can adjust the position of the flag relative to the block boundaries. In the example below we used underscores as prefix.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;      block 1          block 2
|----------------|----------------|
|uiuctf{FAKEFLAG}|                |
|_______________u|iuctf{FAKEFLAG} |
|______________ui|uctf{FAKEFLAG}  |
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Let&amp;rsquo;s assume, we already know the first character (which we do, since all flags start with &lt;code&gt;uiuctf{&lt;/code&gt;). We now can guess the second character by appending the prefix used in the last row of the above example with the already known part of the flag and our guess. If we guess the correct character, the first block will be identical to the one requested with only the underscores.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;     block 1          block 2
|----------------|----------------|
|______________ui|uctf{FAKEFLAG}  |
|                |                |
|______________uA|uiuctf{FAKEFLAG}|
|______________uB|uiuctf{FAKEFLAG}|
|______________ui|uiuctf{FAKEFLAG}|
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;With this knowledge we can begin to write the function for brute forcing one character. It takes a connection to a &lt;code&gt;client&lt;/code&gt;, the already guessed &lt;code&gt;flag&lt;/code&gt; and the &lt;code&gt;alphabet&lt;/code&gt; to use as parameters. At first we request the encrypted blocks to search for by sending only the prefix. This results in the flag being moved to the right, such that the second block will end one character after the already guessed flag characters. Since the encrypted flag spans over two blocks, we send a prefix of 32 minus the number of wanted flag characters as prefix.&lt;/p&gt;
&lt;p&gt;For converting the string to hex, we have to convert the string to bytes first and can then convert them to hex. As pwntools needs the data to send as bytes and the returned hex representation is a string, we have to encode it again.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;brute_force_char&lt;/span&gt;(client, flag, alphabet):
    &lt;span style=&#34;color:#75715e&#34;&gt;# get encrypted flag part&lt;/span&gt;
    client&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;sendline((&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;A&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;31&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;len(flag)))&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;encode()&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;hex()&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;encode())
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;As the remaining blocks won&amp;rsquo;t match, since they contain the remaining flag characters in the search request and the whole flag in the guess requests, we keep only the hex representation of the first two blocks, i.e. 64 hex characters.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;    search &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; client&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;recvline()[:&lt;span style=&#34;color:#ae81ff&#34;&gt;64&lt;/span&gt;]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Now we can iterate over the given alphabet and test each character.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# precompute prefix&lt;/span&gt;
    prefix &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;A&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;31&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;len(flag)) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; flag

    &lt;span style=&#34;color:#75715e&#34;&gt;# iterate over alphabet&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; c &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; alphabet:
        &lt;span style=&#34;color:#75715e&#34;&gt;# encrypt guess&lt;/span&gt;
        client&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;sendline((prefix &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; c)&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;encode()&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;hex()&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;encode())
        recv &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; client&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;recvline()[:&lt;span style=&#34;color:#ae81ff&#34;&gt;64&lt;/span&gt;]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;If the received blocks match with the search pattern, we have found the next flag character and can abort the loop&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;# return if correct char found&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; recv &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; search:
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; c
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;As we now have the initialization of the services and the brute forcing of one flag character done, we can develope the main control flow and define the alphabet of the flag. &lt;code&gt;string.printable&lt;/code&gt; contains all printable ASCII characters, including whitespace.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;ALPHABET &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; string&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;printable
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Furthermore we can define the known start of the flag, as its the same format for all challenges&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;flag &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;uiuctf{&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Before starting the brute forcing, we have to get a client. Since we do not need the server, we can close it.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# get services&lt;/span&gt;
server, client &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; get_services()

&lt;span style=&#34;color:#75715e&#34;&gt;# close server&lt;/span&gt;
server&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;close()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Now we brute force the flag character by character until we reach the closing curly brace.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; flag[&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;}&amp;#34;&lt;/span&gt;:
    flag &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; brute_force_char(client, flag, ALPHABET)

    &lt;span style=&#34;color:#75715e&#34;&gt;# print progress&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt;(flag)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;By running this script, we get the flag after less than two minutes: &lt;code&gt;uiuctf{AES_@_h0m3_b3_l1ke3}&lt;/code&gt;.&lt;/p&gt;
&lt;h1 id=&#34;optimization&#34;&gt;Optimization&lt;/h1&gt;
&lt;p&gt;The acquisition of the search blocks can be optimized by requesting only each of the possible 16 offsets of the flag in a block once and then reusing them. The following example demonstrates this by brute forcing the second (compare only the first block) and the 18. character of the flag (compare the first two blocks).&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;     block 1          block 2          block 3          block 4
|----------------|----------------|----------------|----------------|
|______________ui|uctf{LONGFAKEFLA|G}              |                |
|                |                |                |                |
|______________u?|uiuctf{LONGFAKEF|LAG}            |                |
|______________ui|uiuctf{LONGFAKEF|LAG}            |                |
|                |                |                |                |
|______________ui|uctf{LONGFAKEFL?|uiuctf{LONGFAKEF|LAG}            |
|______________ui|uctf{LONGFAKEFLA|uiuctf{LONGFAKEF|LAG}            |
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This strategy would require to first request all possible search offsets:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;searchs &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; []
&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(&lt;span style=&#34;color:#ae81ff&#34;&gt;16&lt;/span&gt;):
    client&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;sendline((&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;A&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;15&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;i))&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;encode()&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;hex()&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;encode())
    searchs&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(client&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;recvline())
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;brute_force_char&lt;/code&gt; would then use up to 15 prefix characters and compare as many blocks as needed to include characters up to the guessed one.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;brute_force_char&lt;/span&gt;(client, flag, alphabet, searchs):
    &lt;span style=&#34;color:#75715e&#34;&gt;# precompute prefix&lt;/span&gt;
    prefix &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;A&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;15&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; len(flag)&lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;16&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; flag

    &lt;span style=&#34;color:#75715e&#34;&gt;# calculate length of hex representation of prefix + guess&lt;/span&gt;
    compare_length &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; (len(prefix)&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)

    &lt;span style=&#34;color:#75715e&#34;&gt;# get search blocks&lt;/span&gt;
    search &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; searchs[len(flag)&lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;16&lt;/span&gt;][:compare_length]

    &lt;span style=&#34;color:#75715e&#34;&gt;# iterate over alphabet&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; c &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; alphabet:
        &lt;span style=&#34;color:#75715e&#34;&gt;# encrypt guess&lt;/span&gt;
        client&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;sendline((prefix &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; c)&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;encode()&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;hex()&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;encode())
        recv &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; client&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;recvline()[:compare_length]

        &lt;span style=&#34;color:#75715e&#34;&gt;# return if correct char found&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; recv &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; search:
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; c
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The main loop remains identical, except from &lt;code&gt;searchs&lt;/code&gt; being passed as third parameter to &lt;code&gt;brute_force_char&lt;/code&gt;. Since the flag only contains 27 characters, this optimization saves 11 requests, which is negligible compared to the up to 93 tries for the closing curly brace.&lt;/p&gt;
&lt;h1 id=&#34;parallelization&#34;&gt;Parallelization&lt;/h1&gt;
&lt;p&gt;The approach used in the exploit can be parallelized by using multiple connections. Since the session key will be different for each connection, the encrypted plain text and therefore the search pattern will be different and must be requested for each session. Then the alphabet can be distributed between the connections.&lt;/p&gt;
&lt;p&gt;A good library for this is python&amp;rsquo;s &lt;a href=&#34;https://docs.python.org/3/library/concurrent.futures.html&#34;&gt;&lt;code&gt;concurrent.futures&lt;/code&gt;&lt;/a&gt; library. It allows to distribute tasks between a defined number of workers and returning finished tasks without manually querying all workers. Furthermore we will use the &lt;code&gt;threading&lt;/code&gt; library to store data at the worker threads and &lt;code&gt;ceil&lt;/code&gt; from the math library.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; concurrent.futures &lt;span style=&#34;color:#f92672&#34;&gt;as&lt;/span&gt; cf
&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; threading
&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; math
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The main part of &lt;code&gt;concurrent.futures&lt;/code&gt; are the executors. They control the workers and distribute the tasks. &lt;code&gt;concurrent.futures&lt;/code&gt; offers two types of executors: &lt;code&gt;ThreadPoolExecutor&lt;/code&gt; and &lt;code&gt;ProcessPoolExecutor&lt;/code&gt;. As the names indicate, the former one uses threads and the later one subprocesses for it&amp;rsquo;s workers. Concurrency can be solved in multiple ways. Python decided to use the easiest and safest one by introducing the global interpreter lock. This lock ensures, that there is always only one thread executing bytecode. In contrast to threads, subprocesses are, as the name indicates, separate processes, resulting in having an own global interpreter lock for each process. As a consequence, the access to variables outside the process is limited. Furthermore &lt;code&gt;ProcessPolExecutor&lt;/code&gt; cannot be used inside the python console. Since the requests are I/O bound tasks with negligible computing time, there should be no noticeable difference between those two executors. But as threads are more light weight, they can be spawned a bit faster. Because of the beforementioned advantages of threads, we will take the &lt;code&gt;ThreadPoolExecutor&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Since we want to reuse clients for multiple requests, we have to initialize the workers first. Since each client has a different session key, we have to request the search pattern for each client and therefore store it together with the corresponding flag part in the client.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;init_worker&lt;/span&gt;():
    &lt;span style=&#34;color:#75715e&#34;&gt;# get services&lt;/span&gt;
    server, client &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; get_services()

    &lt;span style=&#34;color:#75715e&#34;&gt;# close server&lt;/span&gt;
    server&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;close()

    &lt;span style=&#34;color:#75715e&#34;&gt;# set additional client attributes&lt;/span&gt;
    client&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;flag &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; None
    client&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;search &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; None

    &lt;span style=&#34;color:#75715e&#34;&gt;# store client with the thread&lt;/span&gt;
    threading&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;current_thread()&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;client &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; client
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Now we can adjust the brute force function, which will be executed by the threads. Each run will try only one character. We first have to ensure, that the blocks to search for are the ones for the current flag character. Then we can request the encryption of our try and return the result of the comparison together with the tested character.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;try_character&lt;/span&gt;(flag, char):
    &lt;span style=&#34;color:#75715e&#34;&gt;# get client&lt;/span&gt;
    client &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; threading&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;current_thread()&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;client

    &lt;span style=&#34;color:#75715e&#34;&gt;# test if search pattern is for current flag character&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; client&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;flag &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; flag:
        &lt;span style=&#34;color:#75715e&#34;&gt;# get encrypted flag part&lt;/span&gt;
        client&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;sendline((&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;A&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;31&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;len(flag)))&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;encode()&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;hex()&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;encode())
        client&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;search &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; client&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;recvline()[:&lt;span style=&#34;color:#ae81ff&#34;&gt;64&lt;/span&gt;]

    &lt;span style=&#34;color:#75715e&#34;&gt;# test character&lt;/span&gt;
    client&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;sendline((&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;A&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;31&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;len(flag)) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; flag &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; char)&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;encode()&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;hex()&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;encode())
    test &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; client&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;recvline()[:&lt;span style=&#34;color:#ae81ff&#34;&gt;64&lt;/span&gt;]

    &lt;span style=&#34;color:#75715e&#34;&gt;# return test result&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; test &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; client&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;search, char
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;After we having all prerequisites, we can now rebuild the main control flow, starting with the already known definitions of the flag start and the alphabet.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;flag &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;uiuctf{&amp;#34;&lt;/span&gt;
ALPHABET &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; string&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;printable
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Now we can create the executor. We choose each thread to handle up to five characters, which results in every sixth request being one for the search pattern.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;max_workers &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; math&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;ceil(len(ALPHABET)&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;)
executor &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; cf&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;ThreadPoolExecutor(max_workers&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;max_workers, initializer&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;init_worker)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The main loop looks different this time, since we have to deal with the executor and its results. Since we want to pass the already brute forced part of the flag to &lt;code&gt;try_character&lt;/code&gt;, we cannot use the &lt;code&gt;map&lt;/code&gt; function of the executor and must submit each call ourselves.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; flag[&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;}&amp;#34;&lt;/span&gt;:
    &lt;span style=&#34;color:#75715e&#34;&gt;# get futures&lt;/span&gt;
    futures &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [executor&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;submit(try_character, flag, c) &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; c &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; ALPHABET]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;After having a list with futures, we have to resolve them. By using &lt;code&gt;as_completed&lt;/code&gt;, we get completed futures independent of the order in the passed list. As before, we stop the loop when we found the next flag character.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# handle results&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; future &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; cf&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;as_completed(futures):
        result, char &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; future&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;result()
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; result:
            flag &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; char
            &lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt;(flag)
            &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;But stopping the loop won&amp;rsquo;t stop the executor from executing the futures, so we have to cancel them ourselves. The cancellation of the remaining futures will reduce the runtime from around 30 seconds to around 22 seconds.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# cancel remaining futures&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; future &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; futures:
        future&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;cancel()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;other-modes&#34;&gt;Other Modes&lt;/h1&gt;
&lt;p&gt;In our exploit we used the ECB mode, as it is the easiest one, but other modes can also be used after slight adjustments. So let&amp;rsquo;s have a closer look on the other AES modes featured in this challenge.&lt;/p&gt;
&lt;h2 id=&#34;aes-ctr&#34;&gt;AES CTR&lt;/h2&gt;
&lt;p&gt;The CounTeR mode encrypts the concatenation of a 64 bit nonce and a 64 bit counter and xors the result with the plaintext. Since the nonce and the session key will be different for each connection, the encrypted nonce+counter cannot be predicted. It is possible to infer the encrypted nonce+counter by sending a prefix large enough to know the plaintext of an entire block. But since we do not know the session key, this doesn&amp;rsquo;t enables us to predict the next one. Since encrypting something with AES will result in an equal chance of a bit being 0 or 1, we do not know the encrypted nonce+counter or we have no unknown bit in the plaintext and are therefore unable to infer the flag with this mode. Counter mode has the advantage, that its keys can be precomputed and then xored over the plaintext. Furthermore this mode only requires the possibility to encrypt and is therefore easier to implement.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-goat&#34; data-lang=&#34;goat&#34;&gt;           .-------+----------.              .-------+----------.
           | nonce | 00000001 |              | nonce | 00000002 |
           &#39;-------+----------&#39;              &#39;-------+----------&#39;
                     |                                 |
                     v                                 v
                .---------.                       .---------.
                | encrypt |                       | encrypt |
                &#39;---------&#39;                       &#39;---------&#39;
                     |                                 |
                     v                                 v
.-------------.   .-----.         .-------------.   .-----.
| plaintext 1 |--&amp;gt;| xor |         | plaintext 2 |--&amp;gt;| xor |
&#39;-------------&#39;   &#39;-----&#39;         &#39;-------------&#39;   &#39;-----&#39;
                     |                                 |
                     v                                 v
             .--------------.                  .--------------.
             | ciphertext 1 |                  | ciphertext 2 |
             &#39;--------------&#39;                  &#39;--------------&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;aes-ofb&#34;&gt;AES OFB&lt;/h1&gt;
&lt;p&gt;The Output FeedBack mode starts with encrypting the initialization vector. It then xors the result with the plaintext. For subsequent blocks, the output of the encryption of the previous block is used instead of the initialization vector. Since the initialization vector is not defined, the used python library will generate it randomly. Using this mode has the same consequences as using the counter mode: we can get the output of the encryption by providing 16 known bytes of plaintext or we can include unknown bits in the plaintext but are unable to infer them, since there is an equal chance of the unknown bits to be flipped or not, as the corresponding bits of the encryption result have an equal probability of being 0 or 1. As a consequence, this mode is unsuitable for solving the challenge. Its has the same advantages as the counter mode but has the disadvantage that it is not possible to decode a block without generating all previous keys.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-goat&#34; data-lang=&#34;goat&#34;&gt;         .-----------------------.
         | initialization vector |
         &#39;-----------------------&#39;    .-----------------.
                     |                |                 |
                     v                |                 v
                .---------.           |            .---------.
                | encrypt |           |            | encrypt |
                &#39;---------&#39;           |            &#39;---------&#39;
                     |                |                 |
                     +----------------&#39;                 |
                     |                                  |
                     v                                  v
.-------------.   .-----.          .-------------.   .-----.
| plaintext 1 |--&amp;gt;| xor |          | plaintext 2 |--&amp;gt;| xor |
&#39;-------------&#39;   &#39;-----&#39;          &#39;-------------&#39;   &#39;-----&#39;
                     |                                  |
                     v                                  v
             .--------------.                   .--------------.
             | ciphertext 1 |                   | ciphertext 2 |
             &#39;--------------&#39;                   &#39;--------------&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;aes-eax&#34;&gt;AES EAX&lt;/h1&gt;
&lt;p&gt;In EAX mode, AES will output a tuple with two values. The first one is the plaintext encoded with counter mode and the second one is a tag, which can be used for authentication. Since counter mode is used to generate the plaintext and the tag is generated from the ciphertext, a header unrelated to the plain text and the nonce from counter mode, it is also inappropriate for solving this challenge.&lt;/p&gt;
&lt;h1 id=&#34;aes-cbc&#34;&gt;AES CBC&lt;/h1&gt;
&lt;p&gt;The only mode left is Cipher Block Chaining. It starts with an initialization vector, which is not set in our case and therefore randomly generated. It then xors the initialization vector with the plaintext and encrypts the result. For subsequent blocks, the ciphertext of the previous block is used instead of the initialization vector. This has the effect, that the decryption of each block depends only on the session key and the ciphertext of the previous block, which enables the decryption without decryption of random blocks. Since we know the ciphertext of the previous block and are able to set the prefix of the plaintext freely, we can use this mode to solve the challenge. So let&amp;rsquo;s implement it. Since it might be easier to understand if we implement it without multithreading, we will leave the parallelization and other optimizations to the reader.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-goat&#34; data-lang=&#34;goat&#34;&gt;                        .-------------.                          .-------------.
                        | plaintext 1 |                          | plaintext 2 |
                        &#39;-------------&#39;                          &#39;-------------&#39;
                               |                                        |
                               v                                        v
.-----------------------.   .-----.                                  .-----.
| initialization vector |--&amp;gt;| xor |            .--------------------&amp;gt;| xor |
&#39;-----------------------&#39;   &#39;-----&#39;            |                     &#39;-----&#39;
                               |               |                        |
                               v               |                        v
                          .---------.          |                   .---------.
                          | encrypt |          |                   | encrypt |
                          &#39;---------&#39;          |                   &#39;---------&#39;
                               |               |                        |
                               v               |                        v
                       .--------------.        |                .--------------.
                       | ciphertext 1 |--------&#39;                | ciphertext 2 |
                       &#39;--------------&#39;                         &#39;--------------&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The &lt;code&gt;get_services&lt;/code&gt; function from the original exploit must be slightly adjusted. We can either choose &lt;code&gt;AES.MODE_CBC&lt;/code&gt; directly or just relay the original list and let the client choose it later, as it is the first mode in the list and therefore the default of this challenge.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# relay AES mode list -&amp;gt; client will choose AES.MODE_CBC&lt;/span&gt;
    server&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;send(client&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;recvline())
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Since the last ciphertext block is a relevant property in CBC, we will store it with the connection. The first ciphertext we receive is the encrypted &lt;code&gt;finish&lt;/code&gt; for the server. We can store it directly before the return of &lt;code&gt;get_services&lt;/code&gt;. The client pads the finish message to 32 bytes despite it being shorter than 16 bytes and therefore fitting into only one block. This indicates, that the challenge author set &lt;code&gt;block_size&lt;/code&gt; to 32 bytes. Furthermore we have to strip the new line at the end of the response.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# save last ciphertext block&lt;/span&gt;
    client&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;last &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; finish&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;strip()[&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;32&lt;/span&gt;:]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The main control flow can be left unchanged.&lt;/p&gt;
&lt;p&gt;Unfortunately python does not natively support xoring variables of type &lt;code&gt;bytes&lt;/code&gt;, so we have to write our own helper function. As the right side will always be the raw hex ciphertext, we will also handle the transformation in this helper function.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;bytes_xor_hex&lt;/span&gt;(left, hex_right):
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; bytes(l&lt;span style=&#34;color:#f92672&#34;&gt;^&lt;/span&gt;r &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; l, r &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; zip(left, bytes&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;fromhex(hex_right&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;decode())))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Now we have to actually exploit the challenge. The basic strategy stays the same: we brute force the flag character by character and by aligning the character to brute force against the end of a block. The only thing to do is the xor. Since we cannot xor the flag appended to the prefix, we will leave the entire search request unchanged.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;brute_force_char&lt;/span&gt;(client, flag, alphabet):
    &lt;span style=&#34;color:#75715e&#34;&gt;# get encrypted flag part&lt;/span&gt;
    client&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;sendline((&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;A&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;31&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;len(flag)))&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;encode()&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;hex()&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;encode())
    response &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; client&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;recvline()
    search &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; response[:&lt;span style=&#34;color:#ae81ff&#34;&gt;64&lt;/span&gt;]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;For getting comparable ciphertexts, we have to revert the expected xor with the last ciphertext and apply the xor used for &lt;code&gt;search&lt;/code&gt;. We have to do it only for the first block, because we only change the plaintext from the last character of the second block onwards. By xoring with the last ciphertext block and the one before the first search block, the ciphertext of the first block will be the same as the first one in &lt;code&gt;search&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# precompute prefix ^ search&lt;/span&gt;
    prefix &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;A&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;31&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;len(flag)) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; flag)&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;encode()
    prefix &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; bytes_xor_hex(prefix[:&lt;span style=&#34;color:#ae81ff&#34;&gt;16&lt;/span&gt;], client&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;last) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; prefix[&lt;span style=&#34;color:#ae81ff&#34;&gt;16&lt;/span&gt;:]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Since we no longer need &lt;code&gt;client.last&lt;/code&gt; and can update it with the last block of the last ciphertext.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;    client&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;last &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; response&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;strip()[&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;32&lt;/span&gt;:]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Now we can try all characters of the alphabet. For each request, we have to revert the upcoming xor by xoring with the last ciphertext.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; c &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; alphabet:
        &lt;span style=&#34;color:#75715e&#34;&gt;# encrypt guess&lt;/span&gt;
        request &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; bytes_xor_hex(prefix[:&lt;span style=&#34;color:#ae81ff&#34;&gt;16&lt;/span&gt;], client&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;last) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; prefix[&lt;span style=&#34;color:#ae81ff&#34;&gt;16&lt;/span&gt;:] &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; c&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;encode()
        client&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;sendline(request&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;hex()&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;encode())
        response &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; client&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;recvline()

        &lt;span style=&#34;color:#75715e&#34;&gt;# Update last ciphertext block&lt;/span&gt;
        client&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;last &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; response&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;strip()[&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;32&lt;/span&gt;:]

        &lt;span style=&#34;color:#75715e&#34;&gt;# return if correct char found&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; response[:&lt;span style=&#34;color:#ae81ff&#34;&gt;64&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; search:
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; c
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;And now we get the flag in approximately the same time as the first exploit, even without forcing the client to use ECB.&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title>About</title>
      <link>/about/</link>
      <pubDate>Mon, 14 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>/about/</guid>
      <description>About the taskforce We&amp;rsquo;re a small CTF team from Brunswick in Germany playing CTFs together since 2018.
The group consist of a mix of student and non-student folks studying at TU Braunschweig or hanging out at the local hacker space Stratum 0.
#ctf_zero:stratum0.org</description>
      <content>&lt;h1 id=&#34;about-the-taskforce&#34;&gt;About the taskforce&lt;/h1&gt;
&lt;p&gt;We&amp;rsquo;re a small CTF team from Brunswick in Germany playing CTFs together since 2018.&lt;/p&gt;
&lt;p&gt;The group consist of a mix of student and non-student folks studying
at &lt;a href=&#34;https://www.tu-braunschweig.de/&#34;&gt;TU Braunschweig&lt;/a&gt; or hanging out at the local hacker space &lt;a href=&#34;https://stratum0.org&#34;&gt;Stratum 0&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://matrix.to/#/!uckvhCjNvRXZSATRci:stratum0.org?via=stratum0.org&amp;amp;via=matrix.org&amp;amp;via=entropia.de&#34;&gt;#ctf_zero:stratum0.org&lt;/a&gt;&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title>UIUCTF 2021: back_to_basics</title>
      <link>/posts/uiuctf2021-back-to-basics/</link>
      <pubDate>Tue, 03 Aug 2021 23:59:13 +0100</pubDate>
      
      <guid>/posts/uiuctf2021-back-to-basics/</guid>
      <description>Description: Shoutout to those people who think that base64 is proper encryption
main.py from Crypto.Util.number import long_to_bytes, bytes_to_long from gmpy2 import mpz, to_binary #from secret import flag, key ALPHABET = bytearray(b&amp;#34;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ#&amp;#34;) def base_n_encode(bytes_in, base): return mpz(bytes_to_long(bytes_in)).digits(base).upper().encode() def base_n_decode(bytes_in, base): bytes_out = to_binary(mpz(bytes_in, base=base))[:1:-1] return bytes_out def encrypt(bytes_in, key): out = bytes_in for i in key: print(i) out = base_n_encode(out, ALPHABET.index(i)) return out def decrypt(bytes_in, key): out = bytes_in for i in key: out = base_n_decode(out, ALPHABET.</description>
      <content>&lt;h4 id=&#34;description&#34;&gt;Description:&lt;/h4&gt;
&lt;p&gt;Shoutout to those people who think that base64 is proper encryption&lt;/p&gt;
&lt;h4 id=&#34;mainpy&#34;&gt;main.py&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;from&lt;/span&gt; Crypto.Util.number &lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; long_to_bytes, bytes_to_long
&lt;span style=&#34;color:#f92672&#34;&gt;from&lt;/span&gt; gmpy2 &lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; mpz, to_binary
&lt;span style=&#34;color:#75715e&#34;&gt;#from secret import flag, key&lt;/span&gt;

ALPHABET &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; bytearray(&lt;span style=&#34;color:#e6db74&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ#&amp;#34;&lt;/span&gt;)

&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;base_n_encode&lt;/span&gt;(bytes_in, base):
	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; mpz(bytes_to_long(bytes_in))&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;digits(base)&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;upper()&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;encode()

&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;base_n_decode&lt;/span&gt;(bytes_in, base):
	bytes_out &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; to_binary(mpz(bytes_in, base&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;base))[:&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;:&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]
	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; bytes_out

&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;encrypt&lt;/span&gt;(bytes_in, key):
	out &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; bytes_in
	&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; key:
		&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt;(i)
		out &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; base_n_encode(out, ALPHABET&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;index(i))
	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; out

&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;decrypt&lt;/span&gt;(bytes_in, key):
	out &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; bytes_in
	&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; key:
		out &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; base_n_decode(out, ALPHABET&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;index(i))
	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; out

&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&amp;#34;
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;flag_enc = encrypt(flag, key)
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;f = open(&amp;#34;flag_enc&amp;#34;, &amp;#34;wb&amp;#34;)
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;f.write(flag_enc)
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;f.close()
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;flag_enc&#34;&gt;flag_enc&lt;/h4&gt;
&lt;p&gt;The file can be found in the authors&amp;rsquo; repository: &lt;a href=&#34;https://github.com/sigpwny/UIUCTF-2021-Public/blob/master/crypto/back_to_basics/public/flag_enc&#34;&gt;&lt;code&gt;flag_enc&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Let&amp;rsquo;s look at the provided script:&lt;/p&gt;
&lt;p&gt;As first step the alphabet of the key is defined:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;ALPHABET &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; bytearray(&lt;span style=&#34;color:#e6db74&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ#&amp;#34;&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;base_n_encode&lt;/code&gt; reads the bytes of the given string as one big integer and expresses it in the given base.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;base_n_encode&lt;/span&gt;(bytes_in, base):
	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; mpz(bytes_to_long(bytes_in))&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;digits(base)&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;upper()&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;encode()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;base_n_decode&lt;/code&gt; reads the string as string-representation of a big integer in the given base and returns the binary representation of this integer.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;base_n_decode&lt;/span&gt;(bytes_in, base):
	bytes_out &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; to_binary(mpz(bytes_in, base&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;base))[:&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;:&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]
	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; bytes_out
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;encrypt&lt;/code&gt; takes each char of the key and uses it as base for &lt;code&gt;base_n_encode&lt;/code&gt;. For getting an integer base, the char is searched in the above alphabet and the position is used as base.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;encrypt&lt;/span&gt;(bytes_in, key):
	out &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; bytes_in
	&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; key:
		&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt;(i)
		out &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; base_n_encode(out, ALPHABET&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;index(i))
	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; out
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;decrypt&lt;/code&gt; takes each char of the key and uses in the same way as in &lt;code&gt;encode&lt;/code&gt; for decoding the string with &lt;code&gt;base_n_decode&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;decrypt&lt;/span&gt;(bytes_in, key):
	out &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; bytes_in
	&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; key:
		out &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; base_n_decode(out, ALPHABET&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;index(i))
	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; out
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Finally, there is a comment, which explains, how &lt;code&gt;flag_enc&lt;/code&gt; was created:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;flag_enc &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; encrypt(flag, key)
f &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; open(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;flag_enc&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;wb&amp;#34;&lt;/span&gt;)
f&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;write(flag_enc)
f&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;close()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;p&gt;At the start some considerations:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt; cannot be part of the string, as their indices in the alphabet (&lt;code&gt;0&lt;/code&gt; &amp;amp; &lt;code&gt;1&lt;/code&gt;) are no bases&lt;/li&gt;
&lt;li&gt;The base of the encrypted text will always be greater than each char in the text, as all characters in a string with base &lt;code&gt;b&lt;/code&gt; are from interval &lt;code&gt;[0, b-1]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;With this knowledge, we can start the decryption. First we need to load the encrypted flag:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;with&lt;/span&gt; open(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;flag_enc&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;rb&amp;#34;&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; f:
	out &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; f&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;read()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;For debug purposes we initialize some variables:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;round &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
key &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;As we don&amp;rsquo;t know when we are done, we first loop infinitely. Furthermore we want to keep our debug variable up to date.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; True:
	round &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;First we determine the alphabet of the current string:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;	alphabet &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; set(out)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;We only need the maximum for determining the smallest possible base. And again some debug printing.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;	m &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; max(alphabet)
	&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;{}: used {}, {}&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;format(round, m, alphabet))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Let&amp;rsquo;s get the smallest base. If the char is not found, the script will fail at this point with an error.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;	b &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ALPHABET&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;index(m) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Now we can determine whether the calculated base is in range.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; b &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; len(ALPHABET):
		&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;no&amp;#34;&lt;/span&gt;)
		exit(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Now we can test for all possible bases and collect possible indices&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;	indices &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; list()
	&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(b, len(ALPHABET)):
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;As the decryption can fail, and we don&amp;rsquo;t want the script to be aborted, we have to wrap it in &lt;code&gt;try&lt;/code&gt;. And again some debug printing.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;		&lt;span style=&#34;color:#66d9ef&#34;&gt;try&lt;/span&gt;:
			new_out &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; base_n_decode(out, i)
			&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt;(max(new_out), min(new_out))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;As &lt;code&gt;#&lt;/code&gt; cannot be in the string and as the chars build a continues block in ASCII, we can simply check the boundaries to determine whether the decrypted string matches our requirements and the index is a candidate:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;			&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; max(new_out) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;90&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;and&lt;/span&gt; min(new_out) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;48&lt;/span&gt;:
				indices&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(i)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Because the flag will have some additional chars outside this range, we also check if the decrypted string is a potential flag. For preventing spam, we also check the length and hope, that the flag is shorter than 100 chars. If not, we have to adjust the length.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;			&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; max(new_out) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;125&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;and&lt;/span&gt; min(new_out) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;48&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;and&lt;/span&gt; len(out) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;:
				&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt;(f&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;key: {key + chr(ALPHABET[i])}, possible flag: {new_out}&amp;#34;&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;If the decryption fails, we don&amp;rsquo;t want to do something. As python requires a statement in except, we do some useless assignment.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;		&lt;span style=&#34;color:#66d9ef&#34;&gt;except&lt;/span&gt;:
			log &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;For proceeding, we need an index. Let&amp;rsquo;s exit, if we haven&amp;rsquo;t found one.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; len(indices) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;:
		&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;no&amp;#34;&lt;/span&gt;)
		exit(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Now we must select the index for the next round. As it is unlikely that the base is much higher than the maximum char in the string, we use the smallest working base. As we haven&amp;rsquo;t stored the decrypted string, we have to decrypt it again. Furthermore we append the used character from the alphabet to the key. And again some debug printing.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;	out &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; base_n_decode(out, indices[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;])
	key &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; chr(ALPHABET[indices[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]])
	&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt;(key)
	&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt;(indices)
	&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt;(f&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;{round}: used {chr(ALPHABET[b])}, len: {len(out)}&amp;#34;&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The whole script looks as following:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;from&lt;/span&gt; Crypto.Util.number &lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; long_to_bytes, bytes_to_long
&lt;span style=&#34;color:#f92672&#34;&gt;from&lt;/span&gt; gmpy2 &lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; mpz, to_binary
&lt;span style=&#34;color:#75715e&#34;&gt;#from secret import flag, key&lt;/span&gt;

ALPHABET &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; bytearray(&lt;span style=&#34;color:#e6db74&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ#&amp;#34;&lt;/span&gt;)

&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;base_n_encode&lt;/span&gt;(bytes_in, base):
	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; mpz(bytes_to_long(bytes_in))&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;digits(base)&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;upper()&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;encode()

&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;base_n_decode&lt;/span&gt;(bytes_in, base):
	bytes_out &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; to_binary(mpz(bytes_in, base&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;base))[:&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;:&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]
	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; bytes_out

&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;encrypt&lt;/span&gt;(bytes_in, key):
	out &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; bytes_in
	&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; key:
		&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt;(i)
		out &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; base_n_encode(out, ALPHABET&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;index(i))
	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; out

&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;decrypt&lt;/span&gt;(bytes_in, key):
	out &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; bytes_in
	&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; key:
		out &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; base_n_decode(out, ALPHABET&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;index(i))
	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; out

&lt;span style=&#34;color:#66d9ef&#34;&gt;with&lt;/span&gt; open(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;flag_enc&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;rb&amp;#34;&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; f:
	out &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; f&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;read()

round &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
key &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; True:
	round &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
	alphabet &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; set(out)
	m &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; max(alphabet)
	&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;{}: used {}, {}&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;format(round, m, alphabet))
	b &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ALPHABET&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;index(m) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; b &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; len(ALPHABET):
		&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;no&amp;#34;&lt;/span&gt;)
		exit(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)
	indices &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; list()
	&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(b, len(ALPHABET)):
		&lt;span style=&#34;color:#66d9ef&#34;&gt;try&lt;/span&gt;:
			new_out &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; base_n_decode(out, i)
			&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt;(max(new_out), min(new_out))
			&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; max(new_out) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;90&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;and&lt;/span&gt; min(new_out) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;48&lt;/span&gt;:
				indices&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(i)
			&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; max(new_out) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;125&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;and&lt;/span&gt; min(new_out) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;48&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;and&lt;/span&gt; len(new_out) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;:
				&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt;(f&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;key: {key + chr(ALPHABET[i])}, possible flag: {new_out}&amp;#34;&lt;/span&gt;)
		&lt;span style=&#34;color:#66d9ef&#34;&gt;except&lt;/span&gt;:
			log &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; len(indices) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;:
		&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;no&amp;#34;&lt;/span&gt;)
		exit(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)
	out &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; base_n_decode(out, indices[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;])
	key &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; chr(ALPHABET[indices[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]])
	&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt;(key)
	&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt;(indices)
	&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt;(f&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;{round}: used {chr(ALPHABET[b])}, len: {len(out)}&amp;#34;&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In the output we find the flag (&lt;code&gt;b&#39;uiuctf{r4DixAL}&#39;&lt;/code&gt;) and the corresponding key (&lt;code&gt;WM5Z8CRJABXJDJ5W&lt;/code&gt;).&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title>UIUCTF 2021: dhke_intro</title>
      <link>/posts/uiuctf2021-dhke-intro/</link>
      <pubDate>Tue, 03 Aug 2021 23:59:13 +0100</pubDate>
      
      <guid>/posts/uiuctf2021-dhke-intro/</guid>
      <description>Description: Small numbers are bad in cryptography. This is why.
dhkectf_intro.py import random from Crypto.Cipher import AES # generate key gpList = [ [13, 19], [7, 17], [3, 31], [13, 19], [17, 23], [2, 29] ] g, p = random.choice(gpList) a = random.randint(1, p) b = random.randint(1, p) k = pow(g, a * b, p) k = str(k) # print(&amp;#34;Diffie-Hellman key exchange outputs&amp;#34;) # print(&amp;#34;Public key: &amp;#34;, g, p) # print(&amp;#34;Jotaro sends: &amp;#34;, aNum) # print(&amp;#34;Dio sends: &amp;#34;, bNum) # print() # pad key to 16 bytes (128bit) key = &amp;#34;&amp;#34; i = 0 padding = &amp;#34;uiuctf2021uiuctf2021&amp;#34; while (16 - len(key) !</description>
      <content>&lt;h4 id=&#34;description&#34;&gt;Description:&lt;/h4&gt;
&lt;p&gt;Small numbers are bad in cryptography. This is why.&lt;/p&gt;
&lt;h4 id=&#34;dhkectf_intropy&#34;&gt;dhkectf_intro.py&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; random
&lt;span style=&#34;color:#f92672&#34;&gt;from&lt;/span&gt; Crypto.Cipher &lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; AES

&lt;span style=&#34;color:#75715e&#34;&gt;# generate key&lt;/span&gt;
gpList &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [ [&lt;span style=&#34;color:#ae81ff&#34;&gt;13&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;19&lt;/span&gt;], [&lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;17&lt;/span&gt;], [&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;31&lt;/span&gt;], [&lt;span style=&#34;color:#ae81ff&#34;&gt;13&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;19&lt;/span&gt;], [&lt;span style=&#34;color:#ae81ff&#34;&gt;17&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;23&lt;/span&gt;], [&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;29&lt;/span&gt;] ]
g, p &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; random&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;choice(gpList)
a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; random&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;randint(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, p)
b &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; random&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;randint(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, p)
k &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; pow(g, a &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; b, p)
k &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; str(k)

&lt;span style=&#34;color:#75715e&#34;&gt;# print(&amp;#34;Diffie-Hellman key exchange outputs&amp;#34;)&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;# print(&amp;#34;Public key: &amp;#34;, g, p)&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;# print(&amp;#34;Jotaro sends: &amp;#34;, aNum)&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;# print(&amp;#34;Dio sends: &amp;#34;, bNum)&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;# print()&lt;/span&gt;

&lt;span style=&#34;color:#75715e&#34;&gt;# pad key to 16 bytes (128bit)&lt;/span&gt;
key &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;
i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
padding &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;uiuctf2021uiuctf2021&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;16&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; len(key) &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; len(k)):
    key &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; key &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; padding[i]
    i &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
key &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; key &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; k
key &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; bytes(key, encoding&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;ascii&amp;#39;&lt;/span&gt;)

&lt;span style=&#34;color:#66d9ef&#34;&gt;with&lt;/span&gt; open(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;flag.txt&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;rb&amp;#39;&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; f:
    flag &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; f&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;read()

iv &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; bytes(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;kono DIO daaaaaa&amp;#34;&lt;/span&gt;, encoding &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;ascii&amp;#39;&lt;/span&gt;)
cipher &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; AES&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;new(key, AES&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;MODE_CFB, iv)
ciphertext &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; cipher&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;encrypt(flag)

&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt;(ciphertext&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;hex())
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;outputtxt&#34;&gt;output.txt&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;b31699d587f7daf8f6b23b30cfee0edca5d6a3594cd53e1646b9e72de6fc44fe7ad40f0ea6
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;p&gt;Let&amp;rsquo;s look at the python script:&lt;/p&gt;
&lt;p&gt;The script contains a list of tuples of prime numbers and chooses one tuple randomly. The primes will be used for a Diffie-Hellman key exchange. The first prime will be used as generator and the second one as module.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;gpList &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [ [&lt;span style=&#34;color:#ae81ff&#34;&gt;13&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;19&lt;/span&gt;], [&lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;17&lt;/span&gt;], [&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;31&lt;/span&gt;], [&lt;span style=&#34;color:#ae81ff&#34;&gt;13&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;19&lt;/span&gt;], [&lt;span style=&#34;color:#ae81ff&#34;&gt;17&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;23&lt;/span&gt;], [&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;29&lt;/span&gt;] ]
g, p &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; random&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;choice(gpList)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;After agreeing on the generator, each party generates its secret:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; random&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;randint(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, p)
b &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; random&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;randint(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, p)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Normally the following would happen:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Alice calculates &lt;code&gt;g^a % p&lt;/code&gt; and sends it to Bob, Bob calculates &lt;code&gt;g^b % p&lt;/code&gt; and sends it to Alice&lt;/li&gt;
&lt;li&gt;Alice calculates with the received value from Bob &lt;code&gt;(g^b % p)^a % p&lt;/code&gt;, Bob does the same&lt;/li&gt;
&lt;li&gt;Now Alice and Bob have the same secret key: &lt;code&gt;(g^b % p)^a % p = (g^b)^a % p = g^(b*a) % p = g^(a*b) % p = (g^a)^b % p = (g^a % p)^b % p&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;As the authors use Diffie-Hellman just to generate a key locally, they simplified this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;k &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; pow(g, a &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; b, p)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;After that the key is converted to string for later use:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;k &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; str(k)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;As we now have generated a secret key with Diffie-Hellman this key is used in AES for encrypting the flag.&lt;/p&gt;
&lt;p&gt;As AES needs a 128-bit key, we have to blow up our key. The script chooses the easy way and adds constant padding in front of the key:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# pad key to 16 bytes (128bit)&lt;/span&gt;
key &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;
i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
padding &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;uiuctf2021uiuctf2021&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;16&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; len(key) &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; len(k)):
    key &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; key &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; padding[i]
    i &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
key &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; key &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; k
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Then the key is converted to bytes for the AES-Function:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;key &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; bytes(key, encoding&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;ascii&amp;#39;&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;After that the flag is read from file:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;with&lt;/span&gt; open(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;flag.txt&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;rb&amp;#39;&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; f:
    flag &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; f&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;read()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;AES needs an initialization vector. The authors decided to use a constant initialization vector. This has the advantage, that the initialization vector must not be stored with the encrypted text, so that we can handle the output.txt easier. On the other side this destroys the reason for the initialization vector which should prevent that all messages with the same first block have the same first ciphertext block. As we have only one message, this is irrelevant.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;iv &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; bytes(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;kono DIO daaaaaa&amp;#34;&lt;/span&gt;, encoding &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;ascii&amp;#39;&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Now the flag is encrypted:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;cipher &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; AES&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;new(key, AES&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;MODE_CFB, iv)
ciphertext &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; cipher&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;encrypt(flag)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Finally, the encrypted text is written in hex to the given output.txt:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt;(ciphertext&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;hex())
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;p&gt;Now we can try to decrypt the flag. First we need to read the encrypted flag:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;with&lt;/span&gt; open(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;output.txt&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;r&amp;#34;&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; f:
    output &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; bytearray&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;fromhex(f&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;read())
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;As &lt;code&gt;gpList&lt;/code&gt; is short and the used modules are small, we can simply test all tuples:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; pair &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; gpList:
    g, p &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; pair
    &lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt;(g, p, pair)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;As the module is small, we can test all possible &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. Without loss of generality we can assume &lt;code&gt;b &amp;gt;= a&lt;/code&gt;, since multiplication is commutative.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; a &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, p&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;):
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; b &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(a, p&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;):
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;We have to use &lt;code&gt;p+1&lt;/code&gt;, because &lt;code&gt;randInt(a,b)&lt;/code&gt; uses the interval &lt;code&gt;[a, b]&lt;/code&gt; whereas &lt;code&gt;range(a,b)&lt;/code&gt; uses the interval &lt;code&gt;[a, b)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Now we can copy the computation of the key from the provided encryption script:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;#a = random.randint(1, p)&lt;/span&gt;
    &lt;span style=&#34;color:#75715e&#34;&gt;#b = random.randint(1, p)&lt;/span&gt;
            k &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; pow(g, a &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; b, p)
            k &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; str(k)

    &lt;span style=&#34;color:#75715e&#34;&gt;#print(&amp;#34;Diffie-Hellman key exchange outputs&amp;#34;)&lt;/span&gt;
    &lt;span style=&#34;color:#75715e&#34;&gt;#print(&amp;#34;Public key: &amp;#34;, g, p)&lt;/span&gt;
    &lt;span style=&#34;color:#75715e&#34;&gt;#print(&amp;#34;Jotaro sends: &amp;#34;, aNum)&lt;/span&gt;
    &lt;span style=&#34;color:#75715e&#34;&gt;#print(&amp;#34;Dio sends: &amp;#34;, bNum)&lt;/span&gt;
    &lt;span style=&#34;color:#75715e&#34;&gt;#print()&lt;/span&gt;

            &lt;span style=&#34;color:#75715e&#34;&gt;#pad key to 16 bytes (128bit)&lt;/span&gt;
            key &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;
            i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
            padding &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;uiuctf2021uiuctf2021&amp;#34;&lt;/span&gt;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;16&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; len(key) &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; len(k)):
                key &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; key &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; padding[i]
                i &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
            key &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; key &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; k
            key &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; bytes(key, encoding&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;ascii&amp;#39;&lt;/span&gt;)

            iv &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; bytes(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;kono DIO daaaaaa&amp;#34;&lt;/span&gt;, encoding &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;ascii&amp;#39;&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;After initializing AES&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;            cipher &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; AES&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;new(key, AES&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;MODE_CFB, iv)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;we can try to decrypt the flag.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;            cleartext &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; cipher&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;decrypt(output)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;As we know the beginning of the flag, we can filter the output:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; cleartext[:&lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;uiuctf{&amp;#39;&lt;/span&gt;:
                &lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt;(cleartext)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;When we now execute the script, we will see the correct flag can be decrypted with different tuples and even multiple times per tuple:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[13, 19]
b&#39;uiuctf{omae_ha_mou_shindeiru_b9e5f9}\n&#39;
b&#39;uiuctf{omae_ha_mou_shindeiru_b9e5f9}\n&#39;
b&#39;uiuctf{omae_ha_mou_shindeiru_b9e5f9}\n&#39;
b&#39;uiuctf{omae_ha_mou_shindeiru_b9e5f9}\n&#39;
b&#39;uiuctf{omae_ha_mou_shindeiru_b9e5f9}\n&#39;
b&#39;uiuctf{omae_ha_mou_shindeiru_b9e5f9}\n&#39;
b&#39;uiuctf{omae_ha_mou_shindeiru_b9e5f9}\n&#39;
b&#39;uiuctf{omae_ha_mou_shindeiru_b9e5f9}\n&#39;
b&#39;uiuctf{omae_ha_mou_shindeiru_b9e5f9}\n&#39;
b&#39;uiuctf{omae_ha_mou_shindeiru_b9e5f9}\n&#39;
b&#39;uiuctf{omae_ha_mou_shindeiru_b9e5f9}\n&#39;
[7, 17]
b&#39;uiuctf{omae_ha_mou_shindeiru_b9e5f9}\n&#39;
b&#39;uiuctf{omae_ha_mou_shindeiru_b9e5f9}\n&#39;
b&#39;uiuctf{omae_ha_mou_shindeiru_b9e5f9}\n&#39;
b&#39;uiuctf{omae_ha_mou_shindeiru_b9e5f9}\n&#39;
b&#39;uiuctf{omae_ha_mou_shindeiru_b9e5f9}\n&#39;
b&#39;uiuctf{omae_ha_mou_shindeiru_b9e5f9}\n&#39;
b&#39;uiuctf{omae_ha_mou_shindeiru_b9e5f9}\n&#39;
b&#39;uiuctf{omae_ha_mou_shindeiru_b9e5f9}\n&#39;
b&#39;uiuctf{omae_ha_mou_shindeiru_b9e5f9}\n&#39;
[3, 31]
b&#39;uiuctf{omae_ha_mou_shindeiru_b9e5f9}\n&#39;
b&#39;uiuctf{omae_ha_mou_shindeiru_b9e5f9}\n&#39;
b&#39;uiuctf{omae_ha_mou_shindeiru_b9e5f9}\n&#39;
b&#39;uiuctf{omae_ha_mou_shindeiru_b9e5f9}\n&#39;
b&#39;uiuctf{omae_ha_mou_shindeiru_b9e5f9}\n&#39;
b&#39;uiuctf{omae_ha_mou_shindeiru_b9e5f9}\n&#39;
b&#39;uiuctf{omae_ha_mou_shindeiru_b9e5f9}\n&#39;
b&#39;uiuctf{omae_ha_mou_shindeiru_b9e5f9}\n&#39;
b&#39;uiuctf{omae_ha_mou_shindeiru_b9e5f9}\n&#39;
b&#39;uiuctf{omae_ha_mou_shindeiru_b9e5f9}\n&#39;
b&#39;uiuctf{omae_ha_mou_shindeiru_b9e5f9}\n&#39;
b&#39;uiuctf{omae_ha_mou_shindeiru_b9e5f9}\n&#39;
b&#39;uiuctf{omae_ha_mou_shindeiru_b9e5f9}\n&#39;
[13, 19]
b&#39;uiuctf{omae_ha_mou_shindeiru_b9e5f9}\n&#39;
b&#39;uiuctf{omae_ha_mou_shindeiru_b9e5f9}\n&#39;
b&#39;uiuctf{omae_ha_mou_shindeiru_b9e5f9}\n&#39;
b&#39;uiuctf{omae_ha_mou_shindeiru_b9e5f9}\n&#39;
b&#39;uiuctf{omae_ha_mou_shindeiru_b9e5f9}\n&#39;
b&#39;uiuctf{omae_ha_mou_shindeiru_b9e5f9}\n&#39;
b&#39;uiuctf{omae_ha_mou_shindeiru_b9e5f9}\n&#39;
b&#39;uiuctf{omae_ha_mou_shindeiru_b9e5f9}\n&#39;
b&#39;uiuctf{omae_ha_mou_shindeiru_b9e5f9}\n&#39;
b&#39;uiuctf{omae_ha_mou_shindeiru_b9e5f9}\n&#39;
b&#39;uiuctf{omae_ha_mou_shindeiru_b9e5f9}\n&#39;
[17, 23]
b&#39;uiuctf{omae_ha_mou_shindeiru_b9e5f9}\n&#39;
b&#39;uiuctf{omae_ha_mou_shindeiru_b9e5f9}\n&#39;
b&#39;uiuctf{omae_ha_mou_shindeiru_b9e5f9}\n&#39;
b&#39;uiuctf{omae_ha_mou_shindeiru_b9e5f9}\n&#39;
b&#39;uiuctf{omae_ha_mou_shindeiru_b9e5f9}\n&#39;
b&#39;uiuctf{omae_ha_mou_shindeiru_b9e5f9}\n&#39;
b&#39;uiuctf{omae_ha_mou_shindeiru_b9e5f9}\n&#39;
b&#39;uiuctf{omae_ha_mou_shindeiru_b9e5f9}\n&#39;
b&#39;uiuctf{omae_ha_mou_shindeiru_b9e5f9}\n&#39;
b&#39;uiuctf{omae_ha_mou_shindeiru_b9e5f9}\n&#39;
b&#39;uiuctf{omae_ha_mou_shindeiru_b9e5f9}\n&#39;
b&#39;uiuctf{omae_ha_mou_shindeiru_b9e5f9}\n&#39;
b&#39;uiuctf{omae_ha_mou_shindeiru_b9e5f9}\n&#39;
b&#39;uiuctf{omae_ha_mou_shindeiru_b9e5f9}\n&#39;
b&#39;uiuctf{omae_ha_mou_shindeiru_b9e5f9}\n&#39;
b&#39;uiuctf{omae_ha_mou_shindeiru_b9e5f9}\n&#39;
b&#39;uiuctf{omae_ha_mou_shindeiru_b9e5f9}\n&#39;
[2, 29]
b&#39;uiuctf{omae_ha_mou_shindeiru_b9e5f9}\n&#39;
b&#39;uiuctf{omae_ha_mou_shindeiru_b9e5f9}\n&#39;
b&#39;uiuctf{omae_ha_mou_shindeiru_b9e5f9}\n&#39;
b&#39;uiuctf{omae_ha_mou_shindeiru_b9e5f9}\n&#39;
b&#39;uiuctf{omae_ha_mou_shindeiru_b9e5f9}\n&#39;
b&#39;uiuctf{omae_ha_mou_shindeiru_b9e5f9}\n&#39;
b&#39;uiuctf{omae_ha_mou_shindeiru_b9e5f9}\n&#39;
b&#39;uiuctf{omae_ha_mou_shindeiru_b9e5f9}\n&#39;
b&#39;uiuctf{omae_ha_mou_shindeiru_b9e5f9}\n&#39;
b&#39;uiuctf{omae_ha_mou_shindeiru_b9e5f9}\n&#39;
b&#39;uiuctf{omae_ha_mou_shindeiru_b9e5f9}\n&#39;
b&#39;uiuctf{omae_ha_mou_shindeiru_b9e5f9}\n&#39;
b&#39;uiuctf{omae_ha_mou_shindeiru_b9e5f9}\n&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This has multiple reasons:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;We can redistribute the prime factors of &lt;code&gt;a*b&lt;/code&gt; nearly arbitrary between &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Because of the module, the resulting &lt;code&gt;k&lt;/code&gt; will always be in the interval &lt;code&gt;[0, p-1]&lt;/code&gt;. Since the greatest common divisor between &lt;code&gt;g&lt;/code&gt; and &lt;code&gt;p&lt;/code&gt; is &lt;code&gt;1&lt;/code&gt;, the &lt;code&gt;0&lt;/code&gt; cannot be reached. So &lt;code&gt;k&lt;/code&gt; will be always in the interval &lt;code&gt;[1, p-1]&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;With this knowledge, we can simplify the script:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Search the greatest module and use only this module.&lt;/li&gt;
&lt;li&gt;Iterate over the interval &lt;code&gt;[1, p-1]&lt;/code&gt; and try each for &lt;code&gt;k&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;With this adjustments, we get the following script:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;from&lt;/span&gt; Crypto.Cipher &lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; AES

&lt;span style=&#34;color:#75715e&#34;&gt;# find greatest module&lt;/span&gt;
gpList &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [ [&lt;span style=&#34;color:#ae81ff&#34;&gt;13&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;19&lt;/span&gt;], [&lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;17&lt;/span&gt;], [&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;31&lt;/span&gt;], [&lt;span style=&#34;color:#ae81ff&#34;&gt;13&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;19&lt;/span&gt;], [&lt;span style=&#34;color:#ae81ff&#34;&gt;17&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;23&lt;/span&gt;], [&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;29&lt;/span&gt;] ]
mod &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; g, p &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; gpList:
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; p &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; mod:
        mod &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; p

&lt;span style=&#34;color:#75715e&#34;&gt;# open encrypted flag&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;with&lt;/span&gt; open(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;output.txt&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;r&amp;#34;&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; f:
    output &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; bytearray&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;fromhex(f&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;read())

&lt;span style=&#34;color:#75715e&#34;&gt;# iterate over all possible keys&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, mod):
    k &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; str(i)

    &lt;span style=&#34;color:#75715e&#34;&gt;#pad key to 16 bytes (128bit)&lt;/span&gt;
    key &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;
    i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
    padding &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;uiuctf2021uiuctf2021&amp;#34;&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;16&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; len(key) &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; len(k)):
        key &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; key &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; padding[i]
        i &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
    key &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; key &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; k
    key &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; bytes(key, encoding&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;ascii&amp;#39;&lt;/span&gt;)

    &lt;span style=&#34;color:#75715e&#34;&gt;# initialize AES&lt;/span&gt;
    iv &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; bytes(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;kono DIO daaaaaa&amp;#34;&lt;/span&gt;, encoding &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;ascii&amp;#39;&lt;/span&gt;)
    cipher &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; AES&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;new(key, AES&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;MODE_CFB, iv)

    &lt;span style=&#34;color:#75715e&#34;&gt;# decrypt flag&lt;/span&gt;
    cleartext &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; cipher&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;decrypt(output)

    &lt;span style=&#34;color:#75715e&#34;&gt;# check if cleartext is flag and print flag&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; cleartext[:&lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;uiuctf{&amp;#39;&lt;/span&gt;:
        &lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt;(cleartext)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Now we get the flag only once.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;b&#39;uiuctf{omae_ha_mou_shindeiru_b9e5f9}\n&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Due to the small numbers the time difference between both scripts is negligible (0.90s vs. 0.83s).&lt;/p&gt;
</content>
    </item>
    
  </channel>
</rss>
